# avrySphere Developer Guide: Implementation & Extensibility

This document provides a deep dive into the engineering mechanisms of avrySphere.

## 1. The Kernel Layer (State Management)

avrySphere uses **Zustand** as its "System Bus." The state is divided into discrete stores to prevent global re-renders and ensure high performance.

### Store Hierarchy

- **`useWindowStore`**: The most critical store. Manages the lifecycle of every `WindowState`.
- **`useAuthStore`**: Handles identity synthesis. When a user switches an organization, this store calls `windowStore.loadSession()`, effectively "hot-swapping" the entire desktop state.
- **`useOSStore`**: Manages global hardware parameters like brightness, volume, and panel visibility.
- **`useVFSStore`**: Manages the persistent file tree.

### Session Persistence

Sessions are keyed by `userId:orgId`. This allows a single user to have entirely different window layouts across different organizations. The `_sync()` method in the window store is called after every major move/resize to ensure the state survives a hard refresh.

## 2. Shell Layer (Windowing Engine)

The windowing system is built on top of `react-rnd`, but heavily customized with a "Snap Logic" wrapper.

### Grid Snapping Mechanism

Snapping is calculated in `windowStore.snapWindow`. It uses viewport-aware math:

- **Usable Area**: `window.innerWidth - DOCK_WIDTH`.
- **Snap Patterns**: Implementation includes complex layouts like "Left Two Thirds" (`66.66%` width) and "Three Column Grid."
- **Z-Index Management**: When a window is focused, it recursively finds its parent and all children to elevate the entire "Window Family" to the top of the stack.

### Snap Menu (Portals)

The Advanced Snap Menu (triggered by right-clicking or hovering the maximize button) uses **React Portals**. This ensures the menu is rendered at the root of the document, preventing it from being clipped by the window's `overflow-hidden` container.

## 3. The "Sphere" System (Responsive Paradigms)

Unlike traditional responsive design, avrySphere uses **Spheres**. A Sphere is a complete UI paradigm swap.

- **Logic**: Controlled via `useSphereStore`.
- **Desktop**: Floating windows with a moment dock.
- **Mobile**: Full-screen "cards" with a swipe-up gesture bar (implemented in `MobileNavBar.tsx`).
- **TV/Gaming**: PS5-inspired horizontal navigation using high-resolution icons and ambient gradients.

## 4. Intelligence Layer (Gemini AI)

The `GeminiService` implements a singleton pattern around the `@google/genai` SDK.

### Streaming Implementation

We use asynchronous generators (`async *generateChatStream`) to pipe tokens from the Gemini API directly into the UI. This provides the "typewriter" effect while keeping the UI thread responsive.

### System Instructions

The "Avry AI" persona is enforced via system instructions that define it as a high-performance system assistant, optimizing responses for markdown and technical density.

## 5. Virtual File System (VFS)

The VFS is a flat-map representation of a tree.

- **Structure**: Each item has a `parentId`.
- **Traversal**: Path breadcrumbs are generated by recursively climbing the `parentId` tree until the root is reached.
- **Provisioning**: The `StorageProvisioner.tsx` demonstrates how to "mount" external simulated drives by injecting new root-level nodes into the `vfsStore`.

## üõ†Ô∏è Adding a New Feature

1. **New App**: Add an enum to `types.ts`, create the component in `apps/`, and register it in `AppRegistry.tsx`.
2. **Global Protocol**: To add a URL handler (e.g., `avry://my-app`), update the `launchUrl` method in `osStore.ts`.
3. **New Mode**: Create a new layout in `components/layouts/` and add a conditional trigger in `SphereSpace.tsx`.

---

_avrySphere Core - Engineering for the Next Interface._
